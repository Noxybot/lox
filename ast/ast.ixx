//This file was generated by ast_builder.exe v1.0.0
export module ast;

import <any>;
import <memory>;
import <vector>;

import core;

export namespace ast
{

namespace expr 
{

struct Assign   ;
struct Binary   ;
struct Call     ;
struct Get      ;
struct Grouping ;
struct Logical  ;
struct Set      ;
struct Literal  ;
struct Super    ;
struct This     ;
struct Unary    ;
struct Variable ;

struct VisitorExpr
{
	virtual ~VisitorExpr() = default;
	virtual std::any Visit(const Assign   & val) = 0;
	virtual std::any Visit(const Binary   & val) = 0;
	virtual std::any Visit(const Call     & val) = 0;
	virtual std::any Visit(const Get      & val) = 0;
	virtual std::any Visit(const Grouping & val) = 0;
	virtual std::any Visit(const Logical  & val) = 0;
	virtual std::any Visit(const Set      & val) = 0;
	virtual std::any Visit(const Literal  & val) = 0;
	virtual std::any Visit(const Super    & val) = 0;
	virtual std::any Visit(const This     & val) = 0;
	virtual std::any Visit(const Unary    & val) = 0;
	virtual std::any Visit(const Variable & val) = 0;
};
struct Expr
{
	virtual ~Expr() = default;
	virtual std::any Accept(VisitorExpr& visitor) const = 0;
};

using ExprPtr = std::unique_ptr<Expr>; 

struct Assign    : Expr
{
	Token name;
	std::unique_ptr<Expr> value;
	explicit Assign   (Token name_, std::unique_ptr<Expr> value_)
		: name(std::move(name_))
		, value(std::move(value_))
		{}
	std::any Accept(VisitorExpr& visitor) const override
	{
		return visitor.Visit(*this);
	}
};
struct Binary    : Expr
{
	std::unique_ptr<Expr> left;
	Token op;
	std::unique_ptr<Expr> right;
	explicit Binary   (std::unique_ptr<Expr> left_, Token op_, std::unique_ptr<Expr> right_)
		: left(std::move(left_))
		, op(std::move(op_))
		, right(std::move(right_))
		{}
	std::any Accept(VisitorExpr& visitor) const override
	{
		return visitor.Visit(*this);
	}
};
struct Call      : Expr
{
	std::unique_ptr<Expr> callee;
	Token paren;
	std::vector<ExprPtr> arguments;
	explicit Call     (std::unique_ptr<Expr> callee_, Token paren_, std::vector<ExprPtr> arguments_)
		: callee(std::move(callee_))
		, paren(std::move(paren_))
		, arguments(std::move(arguments_))
		{}
	std::any Accept(VisitorExpr& visitor) const override
	{
		return visitor.Visit(*this);
	}
};
struct Get       : Expr
{
	std::unique_ptr<Expr> object;
	Token name;
	explicit Get      (std::unique_ptr<Expr> object_, Token name_)
		: object(std::move(object_))
		, name(std::move(name_))
		{}
	std::any Accept(VisitorExpr& visitor) const override
	{
		return visitor.Visit(*this);
	}
};
struct Grouping  : Expr
{
	std::unique_ptr<Expr> expression;
	explicit Grouping (std::unique_ptr<Expr> expression_)
		: expression(std::move(expression_))
		{}
	std::any Accept(VisitorExpr& visitor) const override
	{
		return visitor.Visit(*this);
	}
};
struct Logical   : Expr
{
	std::unique_ptr<Expr> left;
	Token op;
	std::unique_ptr<Expr> right;
	explicit Logical  (std::unique_ptr<Expr> left_, Token op_, std::unique_ptr<Expr> right_)
		: left(std::move(left_))
		, op(std::move(op_))
		, right(std::move(right_))
		{}
	std::any Accept(VisitorExpr& visitor) const override
	{
		return visitor.Visit(*this);
	}
};
struct Set       : Expr
{
	std::unique_ptr<Expr> object;
	Token name;
	std::unique_ptr<Expr> value;
	explicit Set      (std::unique_ptr<Expr> object_, Token name_, std::unique_ptr<Expr> value_)
		: object(std::move(object_))
		, name(std::move(name_))
		, value(std::move(value_))
		{}
	std::any Accept(VisitorExpr& visitor) const override
	{
		return visitor.Visit(*this);
	}
};
struct Literal   : Expr
{
	LiteralT value;
	explicit Literal  (LiteralT value_)
		: value(std::move(value_))
		{}
	std::any Accept(VisitorExpr& visitor) const override
	{
		return visitor.Visit(*this);
	}
};
struct Super     : Expr
{
	Token keyword;
	Token method;
	explicit Super    (Token keyword_, Token method_)
		: keyword(std::move(keyword_))
		, method(std::move(method_))
		{}
	std::any Accept(VisitorExpr& visitor) const override
	{
		return visitor.Visit(*this);
	}
};
struct This      : Expr
{
	Token keyword;
	explicit This     (Token keyword_)
		: keyword(std::move(keyword_))
		{}
	std::any Accept(VisitorExpr& visitor) const override
	{
		return visitor.Visit(*this);
	}
};
struct Unary     : Expr
{
	Token op;
	std::unique_ptr<Expr> right;
	explicit Unary    (Token op_, std::unique_ptr<Expr> right_)
		: op(std::move(op_))
		, right(std::move(right_))
		{}
	std::any Accept(VisitorExpr& visitor) const override
	{
		return visitor.Visit(*this);
	}
};
struct Variable  : Expr
{
	Token name;
	explicit Variable (Token name_)
		: name(std::move(name_))
		{}
	std::any Accept(VisitorExpr& visitor) const override
	{
		return visitor.Visit(*this);
	}
};

} //namespace expr

namespace stmt 
{

struct Block      ;
struct Class      ;
struct Expression ;
struct Function   ;
struct If         ;
struct Print      ;
struct Return     ;
struct Var        ;
struct While      ;

struct VisitorStmt
{
	virtual ~VisitorStmt() = default;
	virtual std::any Visit(const Block      & val) = 0;
	virtual std::any Visit(const Class      & val) = 0;
	virtual std::any Visit(const Expression & val) = 0;
	virtual std::any Visit(const Function   & val) = 0;
	virtual std::any Visit(const If         & val) = 0;
	virtual std::any Visit(const Print      & val) = 0;
	virtual std::any Visit(const Return     & val) = 0;
	virtual std::any Visit(const Var        & val) = 0;
	virtual std::any Visit(const While      & val) = 0;
};
struct Stmt
{
	virtual ~Stmt() = default;
	virtual std::any Accept(VisitorStmt& visitor) const = 0;
};

using StmtPtr = std::unique_ptr<Stmt>; 

struct Block       : Stmt
{
	std::vector<StmtPtr> statements;
	explicit Block      (std::vector<StmtPtr> statements_)
		: statements(std::move(statements_))
		{}
	std::any Accept(VisitorStmt& visitor) const override
	{
		return visitor.Visit(*this);
	}
};
struct Class       : Stmt
{
	Token name;
	std::unique_ptr<expr::Variable> superclass;
	std::vector<std::unique_ptr<Function>> methods;
	explicit Class      (Token name_, std::unique_ptr<expr::Variable> superclass_, std::vector<std::unique_ptr<Function>> methods_)
		: name(std::move(name_))
		, superclass(std::move(superclass_))
		, methods(std::move(methods_))
		{}
	std::any Accept(VisitorStmt& visitor) const override
	{
		return visitor.Visit(*this);
	}
};
struct Expression  : Stmt
{
	std::unique_ptr<expr::Expr> expression;
	explicit Expression (std::unique_ptr<expr::Expr> expression_)
		: expression(std::move(expression_))
		{}
	std::any Accept(VisitorStmt& visitor) const override
	{
		return visitor.Visit(*this);
	}
};
struct Function    : Stmt
{
	Token name;
	std::vector<Token> params;
	std::vector<StmtPtr> body;
	explicit Function   (Token name_, std::vector<Token> params_, std::vector<StmtPtr> body_)
		: name(std::move(name_))
		, params(std::move(params_))
		, body(std::move(body_))
		{}
	std::any Accept(VisitorStmt& visitor) const override
	{
		return visitor.Visit(*this);
	}
};
struct If          : Stmt
{
	std::unique_ptr<expr::Expr> condition;
	StmtPtr then_branch;
	StmtPtr else_branch;
	explicit If         (std::unique_ptr<expr::Expr> condition_, StmtPtr then_branch_, StmtPtr else_branch_)
		: condition(std::move(condition_))
		, then_branch(std::move(then_branch_))
		, else_branch(std::move(else_branch_))
		{}
	std::any Accept(VisitorStmt& visitor) const override
	{
		return visitor.Visit(*this);
	}
};
struct Print       : Stmt
{
	std::unique_ptr<expr::Expr> expression;
	explicit Print      (std::unique_ptr<expr::Expr> expression_)
		: expression(std::move(expression_))
		{}
	std::any Accept(VisitorStmt& visitor) const override
	{
		return visitor.Visit(*this);
	}
};
struct Return      : Stmt
{
	Token keyword;
	std::unique_ptr<expr::Expr> value;
	explicit Return     (Token keyword_, std::unique_ptr<expr::Expr> value_)
		: keyword(std::move(keyword_))
		, value(std::move(value_))
		{}
	std::any Accept(VisitorStmt& visitor) const override
	{
		return visitor.Visit(*this);
	}
};
struct Var         : Stmt
{
	Token name;
	std::unique_ptr<expr::Expr> initializer;
	explicit Var        (Token name_, std::unique_ptr<expr::Expr> initializer_)
		: name(std::move(name_))
		, initializer(std::move(initializer_))
		{}
	std::any Accept(VisitorStmt& visitor) const override
	{
		return visitor.Visit(*this);
	}
};
struct While       : Stmt
{
	std::unique_ptr<expr::Expr> condition;
	StmtPtr body;
	explicit While      (std::unique_ptr<expr::Expr> condition_, StmtPtr body_)
		: condition(std::move(condition_))
		, body(std::move(body_))
		{}
	std::any Accept(VisitorStmt& visitor) const override
	{
		return visitor.Visit(*this);
	}
};

} //namespace stmt
}//namespace ast
